// KISSRevShellTest.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
typedef struct IUnknown IUnknown;
#include <Windows.h>
#include <stdio.h>

int main(void)
{
    HANDLE hComm;  // Handle to the Serial port
    BOOL   Status; // Status
    DCB dcbSerialParams = { 0 };  // Initializing DCB structure
    char SerialBuffer[1024] = { 0 }; //Buffer to send and receive data
    DWORD BytesWritten = 0;          // No of bytes written to the port
    char  ReadData;        //temperory Character
    DWORD NoBytesRead;     // Bytes read by ReadFile()
    DWORD dwEventMask;
    unsigned char loop = 0;
    wchar_t pszPortName[10] = { 0 }; //com port id
    wchar_t PortNo[20] = { 0 }; //contain friendly name
    //Enter the com port id
    printf_s("Enter the Com Port: ");
    wscanf_s(L"%s", pszPortName, (unsigned)_countof(pszPortName));
    swprintf_s(PortNo, 20, L"%s", pszPortName);
    //Open the serial com port
    hComm = CreateFile(PortNo, //friendly name
        GENERIC_READ | GENERIC_WRITE,      // Read/Write Access
        0,                                 // No Sharing, ports cant be shared
        NULL,                              // No Security
        OPEN_EXISTING,                     // Open existing port only
        0,                                 // Non Overlapped I/O
        NULL);                             // Null for Comm Devices

    //Setting the Parameters for the SerialPort
    dcbSerialParams.DCBlength = sizeof(dcbSerialParams);
    Status = GetCommState(hComm, &dcbSerialParams); //retreives  the current settings
    dcbSerialParams.BaudRate = CBR_9600;      //BaudRate = 9600
    Status = SetCommState(hComm, &dcbSerialParams);
    
    //const char* ax25_preamble = { "\xc0\x00\xae\x9\xa4\x98\x88\x40\x60\x96\x8a\x6e\xa6\x82\x98\x61\x03\xf0"};
    const char* ax25_preamble = { "\xc0\x00" };
    memcpy(SerialBuffer, ax25_preamble, 2);

    // --------------------------
    // EXEC process
    // --------------------------

    BOOL ok = TRUE;
    HANDLE hStdInPipeRead = NULL;
    HANDLE hStdInPipeWrite = NULL;
    HANDLE hStdOutPipeRead = NULL;
    HANDLE hStdOutPipeWrite = NULL;

    // Create two pipes.
    SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };
    printf_s("%i", sizeof(SECURITY_ATTRIBUTES));
    ok = CreatePipe(&hStdInPipeRead, &hStdInPipeWrite, &sa, 0);
    if (ok == FALSE) return -1;
    ok = CreatePipe(&hStdOutPipeRead, &hStdOutPipeWrite, &sa, 0);
    if (ok == FALSE) return -1;

    // ----------------------------
    // Create the process.
    // ----------------------------
    STARTUPINFO si = { };
    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdError = hStdOutPipeWrite;
    si.hStdOutput = hStdOutPipeWrite;
    si.hStdInput = hStdInPipeRead;
    PROCESS_INFORMATION pi = { };
    LPCSTR lpApplicationName = "C:\\Windows\\System32\\cmd.exe";
    LPSTR lpCommandLine = NULL;
    //LPWSTR lpCommandLine = (LPWSTR)L"C:\\Windows\\System32\\cmd.exe";
    LPSECURITY_ATTRIBUTES lpProcessAttributes = NULL;
    LPSECURITY_ATTRIBUTES lpThreadAttribute = NULL;
    BOOL bInheritHandles = TRUE;
    DWORD dwCreationFlags = 0;
    LPVOID lpEnvironment = NULL;
    LPCSTR lpCurrentDirectory = NULL;
    ok = CreateProcessA(
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttribute,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        lpCurrentDirectory,
        LPSTARTUPINFOA(&si),
        &pi);
    if (ok == FALSE) return -1;

    // Close pipes we do not need.
    CloseHandle(hStdOutPipeWrite);
    CloseHandle(hStdInPipeRead);

    while (true) {

        // -------------------------------
        // Read process pipe to get cmd output
        // -------------------------------

        // The main loop for reading output from the DIR command.
        char buf;
        //buf[0] = '\xc0';
        DWORD dwRead = 1;
        DWORD dwBytesAvail = 0;
        DWORD dwAvail = 0;
        DWORD dwAvailOld = 0;
        loop = 2;      // Length of ax25_preamble
        
        memset(SerialBuffer, sizeof(SerialBuffer), '\0');
      
        printf_s("Waiting for cmd to complete\n");
        /*
        for(;;)
        {
            Sleep(1000);
            //PeekNamedPipe(hStdOutPipeRead, &SerialBuffer, 1023, &dwRead, &dwAvail, NULL);
            {
                if (dwAvail == dwAvailOld)
                {
                    if (ReadFile(hStdOutPipeRead, &SerialBuffer[2], 1021, &dwRead, NULL))
                    {
                        break;
                    }
                }
                else {
                    dwAvailOld = dwAvail;
                }
            }
        }
        */
        Sleep(1000);
        //PeekNamedPipe(hStdOutPipeRead, &SerialBuffer, 1023, &dwRead, &dwAvail, NULL);
        //if (dwAvail) {
            ReadFile(hStdOutPipeRead, &SerialBuffer[2], 1020, &dwRead, NULL);
        //}

        SerialBuffer[0] = '\xc0';
        SerialBuffer[1] = '\x00';
        SerialBuffer[dwRead + 2] = '\xc0';
        SerialBuffer[dwRead + 3] = '\0';
        

        // --------------------------------------
        // Send output over COM port
        // --------------------------------------

        printf_s("Sending data: %s", &SerialBuffer[2]);
        Status = WriteFile(hComm,// Handle to the Serialport
            SerialBuffer,            // Data to be written to the port
            dwRead+3,   // No of bytes to write into the port
            &BytesWritten,  // No of bytes written to the port
            NULL);

        memcpy(SerialBuffer, SerialBuffer + 2, strlen(SerialBuffer + 2));
        printf_s("\nNumber of bytes written to the serail port = %d\n\n", BytesWritten);


        // -------------------------------------
        // Read data from COM port
        // -------------------------------------

        memset(SerialBuffer, sizeof(SerialBuffer), '\0');
        loop = 0;

        //Read data and store in a buffer
        //PeekNamedPipe(hComm, &SerialBuffer, 1023, &dwRead, &dwAvail, NULL);

        //if (dwAvail) {
            int cCount = 0;
            do
            {
                Status = ReadFile(hComm, &ReadData, sizeof(ReadData), &NoBytesRead, NULL);
                if (ReadData == '\xc0') {
                    cCount = cCount + 1;
                }
                else if (NoBytesRead) {
                    if (ReadData != '\0') {
                        SerialBuffer[loop] = ReadData;
                        ++loop;
                    }
                }
            } while (cCount < 2);
            SerialBuffer[loop] = '\r';
            SerialBuffer[loop + 1] = '\n';
            SerialBuffer[loop + 2] = '\0';
            //--loop; //Get Actual length of received data
            printf_s("Received data: %s", SerialBuffer);
            printf_s("\nNumber of bytes received = %d\n\n", loop + 1);

            // -------------------------------------
            // Write command to process pipe
            // -------------------------------------
            int index = 0;
            ok = WriteFile(hStdInPipeWrite, &SerialBuffer, loop + 2, &BytesWritten, NULL);
            printf_s("%i", GetLastError());
            printf_s("\nNumber of bytes written to the pipe = %d\n\n", BytesWritten);
        //}
        //printf_s("%c", SerialBuffer[index]);
    }

   
    // -----------------------------------------
    // Clean up and exit.
    // -----------------------------------------

    //CloseHandle(hStdOutPipeRead);
    //CloseHandle(hStdInPipeWrite);
    //DWORD dwExitCode = 0;
    //GetExitCodeProcess(pi.hProcess, &dwExitCode);

Exit1:
    CloseHandle(hComm);//Closing the Serial Port
Exit2:
    system("pause");
    return 0;
}




